{--

Copyright (c) 2014-2020, Clockwork Dev Studio
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--}

module ParserData where

import LexerData

data StatementID =
     STATEMENT_BEGINNING_OF_FILE |
     STATEMENT_END_OF_FILE |
     STATEMENT_PROGRAM |
     STATEMENT_CODE |
     STATEMENT_COMMENT |
     STATEMENT_NEWLINE |
     STATEMENT_END_STATEMENT |
     STATEMENT_ASM |
     STATEMENT_ASM_DATA |
     STATEMENT_SYS |
     STATEMENT_DIM |
     STATEMENT_EXPRESSION |
     STATEMENT_LABEL |
     STATEMENT_DATA_LABEL |
     STATEMENT_DATA |
     STATEMENT_READ |
     STATEMENT_RESTORE |
     STATEMENT_VARIABLE_LIST |
     STATEMENT_EXPRESSION_LIST |
     STATEMENT_IF |
     STATEMENT_IF_DEFAULT |
     STATEMENT_ELSE_IF |
     STATEMENT_ELSE |
     STATEMENT_SELECT |
     STATEMENT_CASE |
     STATEMENT_DEFAULT |     
     STATEMENT_FOR_HEADER |
     STATEMENT_FOR |
     STATEMENT_FOR_EACH_HEADER |
     STATEMENT_FOR_EACH |
     STATEMENT_WHILE |
     STATEMENT_REPEAT |
     STATEMENT_UNTIL |
     STATEMENT_FOREVER |
     STATEMENT_EXIT |
     STATEMENT_GOTO |
     STATEMENT_GOSUB |
     STATEMENT_ON_GOTO |
     STATEMENT_ON_GOSUB |
     STATEMENT_RETURN |
     STATEMENT_FUNCTION_DEFINITION |
     STATEMENT_FUNCTION_PROTOTYPE |
     STATEMENT_CONST |
     STATEMENT_GLOBAL |
     STATEMENT_LOCAL |
     STATEMENT_MULTI_FUNCTION |
     STATEMENT_MULTI_FUNCTION_RETURN |
     STATEMENT_TYPE |
     STATEMENT_INSERT_BEFORE |
     STATEMENT_INSERT_AFTER |
     STATEMENT_DELETE |
     STATEMENT_DELETE_EACH |
     STATEMENT_END |
     STATEMENT_NONE |

     EXPRESSION_IDENTIFIER |
     EXPRESSION_INT_CONSTANT |
     EXPRESSION_FLOAT_CONSTANT |
     EXPRESSION_STRING_CONSTANT |
     EXPRESSION_HEX_CONSTANT |
     EXPRESSION_BIN_CONSTANT |
     EXPRESSION_PI |
     EXPRESSION_TRUE |
     EXPRESSION_FALSE |
     EXPRESSION_NULL |
     EXPRESSION_ASSIGN |
     EXPRESSION_AND |
     EXPRESSION_OR |
     EXPRESSION_XOR |
     EXPRESSION_NOT |
     EXPRESSION_EQUAL_TO |
     EXPRESSION_NOT_EQUAL_TO |
     EXPRESSION_GREATER_THAN |
     EXPRESSION_LESS_THAN |
     EXPRESSION_GREATER_THAN_OR_EQUAL_TO |
     EXPRESSION_LESS_THAN_OR_EQUAL_TO |
     EXPRESSION_INT |
     EXPRESSION_FLOAT |
     EXPRESSION_STR |
     EXPRESSION_ADD |
     EXPRESSION_SUB |
     EXPRESSION_MUL |
     EXPRESSION_DIV |
     EXPRESSION_MOD |
     EXPRESSION_NEG |
     EXPRESSION_POS |
     EXPRESSION_BITWISE_COMPLEMENT |
     EXPRESSION_POW |
     EXPRESSION_SHL |
     EXPRESSION_SHR |
     EXPRESSION_SAR |
     EXPRESSION_GROUP |
     EXPRESSION_FUNCTION_CALL |
     EXPRESSION_NEW |
     EXPRESSION_FIELD_ACCESS |
     EXPRESSION_FIRST |
     EXPRESSION_LAST |
     EXPRESSION_BEFORE |
     EXPRESSION_AFTER     

     deriving (Show, Eq)

data Statement =
     Statement
     {
       statementID :: StatementID,
       statementLineNumber :: Int,
       statementOffset :: Int,
       statementContents :: [Statement]
     } |
     IdentifierExpression
     {
       identifierExpressionValue :: String
     } |
     IntConstantExpression
     {
       intConstantExpressionValue :: Int
     } |
     FloatConstantExpression
     {
       floatConstantExpressionValue :: Double
     } |
     StringConstantExpression
     {
       stringConstantExpressionValue :: String
     } |
     HexConstantExpression
     {
       hexConstantExpressionValue :: String
     } |
     BinConstantExpression
     {
       binConstantExpressionValue :: String
     } |
     PiExpression |
     TrueExpression |
     FalseExpression |
     NullExpression |
     RawRegister
     {
       rawRegisterName :: String,
       rawRegisterType :: VariableType
     } |
     InlineAsm
     {
       inlineAsm :: [String]
     } |
     STATEMENT_TOKEN |     
     EmptyStatement
     
     deriving (Show, Eq)

data VariableType =
     VARIABLE_TYPE_INT |
     VARIABLE_TYPE_FLOAT |
     VARIABLE_TYPE_STRING |
     VARIABLE_TYPE_ARRAY
     {
       targetType :: VariableType
     } |
     VARIABLE_TYPE_CUSTOM
     {
       customTypeName :: String
     } |
     VARIABLE_TYPE_NULL |
     VARIABLE_TYPE_VOID
     deriving (Show, Eq)

data Operator =
     Operator
     {operatorTokenID :: TokenID,
      operatorExpressionID :: StatementID,
      operatorPrecedence :: Int,
      operatorAssociativity :: Associativity}
     deriving (Show, Eq)

data Associativity =
     ASSOCIATIVITY_LEFT |
     ASSOCIATIVITY_RIGHT |
     ASSOCIATIVITY_INNER

     deriving (Show, Eq)

prefixOperators =
  [Operator TOKEN_NOT EXPRESSION_NOT 0 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_SUB EXPRESSION_NEG 7 ASSOCIATIVITY_RIGHT, 
   Operator TOKEN_ADD EXPRESSION_POS 7 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_BITWISE_COMPLEMENT EXPRESSION_BITWISE_COMPLEMENT 7 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_BEFORE EXPRESSION_BEFORE 9 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_AFTER EXPRESSION_AFTER 9 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_NEW EXPRESSION_NEW 10 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_FIRST EXPRESSION_FIRST 10 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_LAST EXPRESSION_LAST 10 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_LEFT_PARENTHESIS EXPRESSION_GROUP 11 ASSOCIATIVITY_INNER]

infixOperators =
  [Operator TOKEN_AND EXPRESSION_AND 1 ASSOCIATIVITY_LEFT,
   Operator TOKEN_OR EXPRESSION_OR 1 ASSOCIATIVITY_LEFT,
   Operator TOKEN_XOR EXPRESSION_XOR 1 ASSOCIATIVITY_LEFT,

   Operator TOKEN_EQUAL_TO EXPRESSION_EQUAL_TO 2 ASSOCIATIVITY_LEFT,
   Operator TOKEN_NOT_EQUAL_TO EXPRESSION_NOT_EQUAL_TO 2 ASSOCIATIVITY_LEFT,
   Operator TOKEN_GREATER_THAN EXPRESSION_GREATER_THAN 2 ASSOCIATIVITY_LEFT,
   Operator TOKEN_LESS_THAN EXPRESSION_LESS_THAN 2 ASSOCIATIVITY_LEFT,
   Operator TOKEN_GREATER_THAN_OR_EQUAL_TO EXPRESSION_GREATER_THAN_OR_EQUAL_TO 2 ASSOCIATIVITY_LEFT,
   Operator TOKEN_LESS_THAN_OR_EQUAL_TO EXPRESSION_LESS_THAN_OR_EQUAL_TO 2 ASSOCIATIVITY_LEFT,

   Operator TOKEN_ADD EXPRESSION_ADD 3 ASSOCIATIVITY_LEFT,
   Operator TOKEN_SUB EXPRESSION_SUB 3 ASSOCIATIVITY_LEFT,

   Operator TOKEN_SHL EXPRESSION_SHL 4 ASSOCIATIVITY_LEFT,
   Operator TOKEN_SHR EXPRESSION_SHR 4 ASSOCIATIVITY_LEFT,
   Operator TOKEN_SAR EXPRESSION_SAR 4 ASSOCIATIVITY_LEFT,
   
   Operator TOKEN_MUL EXPRESSION_MUL 5 ASSOCIATIVITY_LEFT,
   Operator TOKEN_DIV EXPRESSION_DIV 5 ASSOCIATIVITY_LEFT,
   Operator TOKEN_MOD EXPRESSION_MOD 5 ASSOCIATIVITY_LEFT,
   
   Operator TOKEN_POW EXPRESSION_POW 6 ASSOCIATIVITY_RIGHT,
   
   Operator TOKEN_LEFT_PARENTHESIS EXPRESSION_FUNCTION_CALL 11 ASSOCIATIVITY_LEFT,
   Operator TOKEN_FIELD_ACCESS EXPRESSION_FIELD_ACCESS 12 ASSOCIATIVITY_LEFT]

infixOperatorsR =
  [Operator TOKEN_EQUAL_TO EXPRESSION_ASSIGN 1 ASSOCIATIVITY_RIGHT,
   Operator TOKEN_LEFT_PARENTHESIS EXPRESSION_FUNCTION_CALL 11 ASSOCIATIVITY_LEFT,
   Operator TOKEN_FIELD_ACCESS EXPRESSION_FIELD_ACCESS 12 ASSOCIATIVITY_LEFT]


atomList =
  [EXPRESSION_INT_CONSTANT,
   EXPRESSION_BIN_CONSTANT,
   EXPRESSION_HEX_CONSTANT,
   EXPRESSION_FLOAT_CONSTANT,
   EXPRESSION_STRING_CONSTANT,
   EXPRESSION_IDENTIFIER,
   EXPRESSION_PI,
   EXPRESSION_TRUE,
   EXPRESSION_FALSE,
   EXPRESSION_NULL]

atomTokenList =
  [TOKEN_IDENTIFIER,
   TOKEN_INT_CONSTANT,
   TOKEN_FLOAT_CONSTANT,
   TOKEN_STRING_CONSTANT,
   TOKEN_HEX_CONSTANT,
   TOKEN_BIN_CONSTANT,
   TOKEN_NULL,
   TOKEN_TRUE,
   TOKEN_FALSE,
   TOKEN_PI]
   
writableExpressionTypes =
  [EXPRESSION_IDENTIFIER,
   EXPRESSION_FUNCTION_CALL,
   EXPRESSION_FIELD_ACCESS]

standaloneExpressionTypes =
  [EXPRESSION_FUNCTION_CALL]

unaryOperatorList =

  [EXPRESSION_NEG,
   EXPRESSION_POS,
   EXPRESSION_BITWISE_COMPLEMENT,
   EXPRESSION_NOT,
   EXPRESSION_INT,
   EXPRESSION_FLOAT,
   EXPRESSION_STR,
   EXPRESSION_NEW,
   EXPRESSION_GROUP,
   EXPRESSION_FIRST,
   EXPRESSION_LAST,
   EXPRESSION_BEFORE,
   EXPRESSION_AFTER]

nastyTokenHack =
  [TOKEN_LEFT_PARENTHESIS,
   TOKEN_SUB,
   TOKEN_ADD,
   TOKEN_BITWISE_COMPLEMENT,
   TOKEN_NOT,
   TOKEN_NEW,
   TOKEN_FIRST,
   TOKEN_LAST,
   TOKEN_BEFORE,
   TOKEN_AFTER]

endOfBlockTokens =
  [TOKEN_NONE,
   TOKEN_NEXT,
   TOKEN_WEND,
   TOKEN_UNTIL,
   TOKEN_FOREVER,
   TOKEN_ELSE_IF,
   TOKEN_ELSE,
   TOKEN_END_IF,
   TOKEN_CASE,
   TOKEN_DEFAULT,
   TOKEN_END_SELECT,
   TOKEN_END_FUNCTION]

binaryOperatorList =

  [EXPRESSION_ASSIGN,
   EXPRESSION_OR,
   EXPRESSION_AND,
   EXPRESSION_EQUAL_TO,
   EXPRESSION_NOT_EQUAL_TO,
   EXPRESSION_GREATER_THAN,
   EXPRESSION_LESS_THAN,
   EXPRESSION_GREATER_THAN_OR_EQUAL_TO,
   EXPRESSION_LESS_THAN_OR_EQUAL_TO,
   EXPRESSION_ADD,
   EXPRESSION_SUB,
   EXPRESSION_MUL,
   EXPRESSION_DIV,
   EXPRESSION_MOD,
   EXPRESSION_POW,
   EXPRESSION_SHL,
   EXPRESSION_SHR,
   EXPRESSION_SAR,
   EXPRESSION_FIELD_ACCESS]

relationalOperatorList =

  [EXPRESSION_EQUAL_TO,
   EXPRESSION_NOT_EQUAL_TO,
   EXPRESSION_GREATER_THAN,
   EXPRESSION_LESS_THAN,
   EXPRESSION_GREATER_THAN_OR_EQUAL_TO,
   EXPRESSION_LESS_THAN_OR_EQUAL_TO]

typeListOperatorList =
  [EXPRESSION_FIRST,
   EXPRESSION_LAST,
   EXPRESSION_BEFORE,
   EXPRESSION_AFTER]

typeConversionOperatorList =
  [EXPRESSION_INT,
   EXPRESSION_FLOAT,
   EXPRESSION_STR]

meaninglessTokens =

  [TOKEN_NEWLINE]

createMinimalStatement :: StatementID -> [Statement] -> Statement
createMinimalStatement id contents = Statement id 0 0 contents

